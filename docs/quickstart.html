<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Quickstart</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Spandex</span> <span class="project-version">0.5.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="quickstart.html"><div class="inner"><span>Quickstart</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>qbits</span></div></div></li><li class="depth-2"><a href="qbits.spandex.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spandex</span></div></a></li><li class="depth-3 branch"><a href="qbits.spandex.client-options.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client-options</span></div></a></li><li class="depth-3 branch"><a href="qbits.spandex.sniffer-options.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sniffer-options</span></div></a></li><li class="depth-3 branch"><a href="qbits.spandex.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li><li class="depth-3 branch"><a href="qbits.spandex.url.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>url</span></div></a></li><li class="depth-3"><a href="qbits.spandex.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#quickstart" name="quickstart"></a>Quickstart</h1>
<h2><a href="#setup" name="setup"></a>Setup</h2>
<pre><code class="clojure">(require '[qbits.spandex :as s])

(def c (s/client {:hosts ["http://127.0.0.1:9200" "https://foo2:3838"]}))

;; add optional sniffer
(def s (s/sniffer c {... options ...}))
</code></pre>
<h2><a href="#blocking-requests" name="blocking-requests"></a>Blocking requests</h2>
<pre><code class="clojure">(s/request c {:url "/entries/entry/_search"
              :method :get
              :body {:query {:match_all {}}}})

&gt;&gt; {:body {:_index "entries", :_type "entry", :_id "AVkDDJvdkd2OsNWu4oYk", :_version 1, :_shards {:total 2, :successful 1, :failed 0}, :created true}, :status 201, :headers {"Content-Type" "application/json; charset=UTF-8", "Content-Length" "141"}, :host #object[org.apache.http.HttpHost 0x62b90fad "http://127.0.0.1:9200"]}

</code></pre>
<h2><a href="#async-requests-callbacks-" name="async-requests-callbacks-"></a>Async requests (callbacks)</h2>
<pre><code class="clojure">(s/request-async c {:url "/urls/url/"
                    :method :get
                    :body {:query {:match {:message "this is a test"}}}
                    :success (fn [response-as-clj] ... )
                    :error (fn [ex] :boom)})
</code></pre>
<h2><a href="#async-requests-" name="async-requests-"></a>Async requests: <code>core.async/promise-chan</code></h2>
<pre><code class="clojure"><br />(require '[clojure.core.async :as async])

(async/&lt;!! (s/request-chan c {:url "/urls/url/"
                              :method :get
                              :body {:query {:match {:message "this is a test"}}}}))
</code></pre>
<h2><a href="#scrolling" name="scrolling"></a>Scrolling</h2>
<p>Scrolling via core.async (fully NIO internally), interuptable if you async/close! the returned chan.</p>
<pre><code class="clojure">(async/go
  (let [ch (s/scroll-chan client {:url "/foo/_search" :body {:query {:match_all {}}}})]
    (loop []
      (when-let [page (async/&lt;! ch)]
        (do-something-with-page page)
        (recur)))))
</code></pre>
<h2><a href="#simple-bulk-request" name="simple-bulk-request"></a>Simple bulk request</h2>
<p>You can just do it this way, but <code>bulk-chan</code> (below) is way nicer for this.</p>
<pre><code class="clojure">(s/request c {:url "/_bulk"
              :method :put
              :body (s/chunks-&gt;body [{:delete {:_index "foo" :_id "1234"}}
                                     {:_index :bar}
                                     {:create {...}}])})
</code></pre>
<h2><a href="#bulk-requests-scheduling" name="bulk-requests-scheduling"></a>Bulk requests scheduling</h2>
<p>“Faux streaming” of _bulk requests (flushes bulk request after interval or threshold, you can specify these as options). Uses request-chan internally, so it’s quite cheap.</p>
<pre><code class="clojure">(let [{:keys [input-ch output-ch]} (bulk-chan client {:flush-threshold 100
                                                      :flush-interval 5000
                                                      :max-concurrent-requests 3})]
  ;; happily takes a sequence of actions or single fragments
  (async/put! input-ch [{:delete {:_index "foo" :_id "1234"}} {:_index :bar} {:create {...}}])
  (async/put! input-ch {"delete" {"_index" "website" "_type" "blog" "_id" "123"}}))

;; setup an response consumer (we just want to make sure we don't clog this channel)
(future (loop [] (async/&lt;!! (:output-ch c))))
</code></pre></div></div></div></body></html>